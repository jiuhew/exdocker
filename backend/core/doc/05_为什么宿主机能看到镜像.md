# 为什么在宿主机能看到镜像？

## 核心结论

- 看到镜像是**正常现象**。镜像由宿主机上的 Docker 守护进程管理并缓存，用于创建容器。

- 镜像 ≠ 容器 ≠ 进程：
  - 镜像（Images）：只读模板，如 `python:3.12-slim`、`node:22-alpine`、`nginx:1.27-alpine`，以及项目构建出的 `react_explore-backend`、`react_explore-frontend`。
  - 容器（Containers）：镜像的运行实例，如 `rx_backend`、`rx_frontend`。
  - 进程（Processes）：真正跑在容器里的 `python`/`node` 进程（在 Windows 下通常跑在 WSL2/轻量 VM 中），不是宿主 Windows 进程。

## 为什么镜像会在宿主机出现

- 构建与拉取发生在宿主机的 Docker（Windows 下是 Docker Desktop，底层是 WSL2/VM）。

- `FROM python:3.12-slim`/`FROM node:22-alpine` 等会拉取基础镜像，构建完成后镜像会缓存在宿主机的本地镜像仓库中，便于后续复用与离线构建。

## 但为什么看不到宿主机上的 node/python 进程

- 因为它们是在**容器内部**运行（WSL2/VM 中的 Linux 进程），不是宿主 Windows 进程，任务管理器默认看不到。

## 快速自检

- 列出镜像（宿主机缓存）：

```bash
docker images
```

- 查看容器状态：

```bash
docker compose ps
```

- 查看容器内进程：

```bash
docker compose exec frontend sh -lc "ps -ef | grep node | grep -v grep"
docker compose exec backend  sh -lc "ps -ef | grep python | grep -v grep"
```

## 小结

- 宿主机能看到镜像：因为镜像被拉取/构建并保存在宿主机，用于创建容器。

- 实际的 `node`/`python` 执行在容器内部（WSL2/VM），与宿主机进程空间隔离。

## 为什么在宿主机任务管理器里看不到 python/node？如何验证它们在运行？

- 容器运行在 Docker Desktop 的 Linux VM/WSL2 中，进程属于该 VM，而非宿主 Windows 进程。宿主侧通常只会看到 `vmmem`/`com.docker.backend`/`dockerd` 等进程。

- 验证方式：

```bash
# 列出服务容器的进程（Compose 级别）
docker compose top backend

docker compose top frontend

# 或直接对具体容器查看
docker top rx_backend

docker top rx_frontend

# 进入容器查看详细进程
docker compose exec backend  sh -lc "ps -ef | head -n 5; ps -ef | grep python | grep -v grep"
docker compose exec frontend sh -lc "ps -ef | head -n 5; ps -ef | grep node   | grep -v grep"
```

- 查看日志：

```bash
docker compose logs backend -f
docker compose logs frontend -f
```

## 如果希望在宿主机直接运行（可选方案）

- 后端（本地虚拟环境）：
  1. `py -3.12 -m venv .venv && .\.venv\Scripts\Activate.ps1`
  2. `pip install -r backend\requirements.txt`
  3. 设置本地连接 Docker 中 MySQL/Redis 的环境变量或 `.env.local`
  4. `python backend\manage.py runserver 0.0.0.0:8000`

- 前端（本地 Node）：
  1. `cd frontend && npm i`
  2. `npm run dev`

## VS Code 中的查看方式

- Docker 扩展：右键容器 → View Logs / Attach Shell。

- Dev Containers 扩展：在容器内打开工作区，IDE 的解释器与进程视图均来自容器环境。
