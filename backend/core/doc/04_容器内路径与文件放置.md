# 容器内路径与文件放置规则

本文解释：为什么 `backend` 最终出现在容器的 `/app`，以及各服务文件如何被定义并落位到容器内。

## 关键机制：Dockerfile 与 Compose 的协同

- Dockerfile 决定"镜像内的默认目录结构"（构建期）。
  - 例如后端的 `backend/Dockerfile`：
    - `WORKDIR /app` 设置工作目录为 `/app`
    - `COPY . /app` 将构建上下文（`backend/`）复制到镜像的 `/app`

- Docker Compose 决定"容器运行时的挂载与覆盖"（运行期）。
  - 在 `docker-compose.yml` 的 `backend` 服务：
    - `build: ./backend` 指定 Dockerfile 构建上下文
    - `volumes: - ./backend:/app` 将宿主机的 `backend/` 目录绑定挂载到容器 `/app`
  - 运行时，这个绑定挂载会"覆盖"镜像内先前 `COPY` 的内容，从而实现热更新（你在宿主机改代码，容器内立刻可见）。

因此，"为什么 `backend` 在容器里是 `/app`？"——因为 Dockerfile 规定工作目录是 `/app`，而 Compose 又把宿主的 `backend/` 绑定到 `/app`，两者共同决定了此落位。

## 各服务的路径与文件落位

### 后端（Django + Celery）

- 镜像：由 `backend/Dockerfile` 构建
  - `WORKDIR /app`
  - `COPY . /app`（构建期）

- 容器（Compose 运行期）：
  - `volumes: - ./backend:/app`（宿主 `backend/` → 容器 `/app`）
  - `volumes: - static_volume:/app/static`（命名卷存放静态文件收集结果）
  - `volumes: - media_volume:/app/media`（命名卷存放媒体上传）

- 典型容器内路径：
  - 代码：`/app/manage.py`、`/app/core/...`、`/app/apps/...`
  - 静态输出：`/app/static`（映射到 `static_volume`）
  - 媒体：`/app/media`（映射到 `media_volume`）

- `celery`、`celery-beat` 服务与 `backend` 复用同一镜像与代码挂载，只是 `command` 不同。

### 前端（Vite + React）

- 镜像：`frontend/Dockerfile`
  - `WORKDIR /app`
  - 安装依赖、启动 dev server（端口 3000）

- 容器（Compose 运行期）：
  - `volumes: - ./frontend:/app`（宿主 `frontend/` → 容器 `/app`）
  - `volumes: - /app/node_modules`（匿名卷，避免主机覆盖容器内安装结果）

### MySQL

- 官方镜像内数据目录：`/var/lib/mysql`

- 容器（Compose 运行期）：
  - `volumes: - mysql_data:/var/lib/mysql`（命名卷持久化数据）
  - `volumes: - ./docker/mysql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro`（首次启动自动执行初始化 SQL）

### Redis

- 官方镜像内数据目录（持久化开启时）：`/data`

- 容器（Compose 运行期）：
  - `volumes: - redis_data:/data`

### Nginx

- 官方镜像内配置目录：`/etc/nginx`

- 容器（Compose 运行期）：
  - `volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro`
  - `volumes: - ./nginx/conf.d:/etc/nginx/conf.d:ro`

- 反向代理目标：`proxy_pass http://rx_backend:8000/api/;`（容器间通过服务名互访）

## 构建期 vs 运行期：覆盖关系

- 构建期（Dockerfile）：将代码 `COPY` 到镜像 `/app`，用于无挂载/生产镜像的运行。

- 运行期（Compose）：为开发热更，绑定宿主源码目录到同一路径 `/app`，覆盖镜像内同路径内容。
  - 这就是"你改宿主代码，容器里立即生效"的根本原因。

## 如何验证容器内实际落位

- 看挂载：

```bash
docker inspect -f "{{range .Mounts}}{{.Source}} -> {{.Destination}} ({{.Type}})\n{{end}}" rx_backend
```

- 看目录：

```bash
docker compose exec backend sh -lc "pwd; ls -la"
```

- 快速确认 Nginx 配置是否正确挂载：

```bash
docker compose exec nginx sh -lc "nginx -T | sed -n '1,80p'"
```

## Windows 说明

- Compose 在 Windows 上将 `C:\...\backend` 以绑定挂载形式映射到容器的 `/app`。

- 如果遇到权限/共享问题：Docker Desktop → Settings → Resources → File Sharing，确保共享了包含项目的盘符。

## 小结

- `backend` 出现在容器 `/app`：源于 Dockerfile 的 `WORKDIR /app` + Compose 的 `./backend:/app` 绑定。

- 代码类目录用绑定挂载（便于开发），数据类目录用命名卷（便于持久化），配置用只读挂载（确保容器内使用你仓库中的配置）。
