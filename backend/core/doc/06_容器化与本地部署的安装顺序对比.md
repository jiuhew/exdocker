# 容器化与本地部署的安装顺序对比

本文对比在“本地直接部署（不使用 Docker）”与“容器化（Docker Compose 编排）”下的安装顺序与日常开发方式差异，技术栈如下：

- 前端: React 18 + Vite + TypeScript（Node 22）
- 后端: Django 5.x + DRF（Python 3.12）
- 队列: Celery 5.x（Redis 7.4 作为 broker/result）
- 数据库: MySQL 8.4
- 反代: Nginx 1.27

---

## 一、核心区别（先理解再动手）

- 本地部署：将语言运行时与依赖直接安装到你的操作系统或本地虚拟环境中（Node、Python、pip 包等）。你在宿主机执行 `django-admin`/`vite`/`celery` 等命令。
- 容器化：将运行时与依赖封装进镜像，通过 Compose 编排启动多个容器。你在宿主机只需要安装 Docker 与 Compose，大部分开发命令通过 `docker compose exec <service> ...` 在容器内执行。
- 结果：安装顺序从“先装语言环境再创建项目”变为“先准备 Compose 与镜像，再在容器内执行项目生成/依赖安装”。

---

## 二、安装顺序对比（速查表）

### 本地部署（无 Docker）

1. 安装 Node.js 22
2. 安装 Python 3.12
3. 安装 MySQL 8.4（本地服务）
4. 安装 Redis 7.4（本地服务）
5. 创建前端项目：
   - `npm create vite@latest frontend -- --template react-ts`
   - `cd frontend && npm i`
6. 创建后端项目：
   - `py -3.12 -m venv .venv && source .venv/bin/activate`（或 PowerShell 版本）
   - `pip install django djangorestframework celery redis pymysql cryptography`（或使用 `requirements.txt`）
   - `django-admin startproject core backend`
7. 本地配置数据库/Redis 连接（`.env.local` 或系统环境变量）
8. 启动：
   - 前端：`cd frontend && npm run dev`
   - 后端：`python backend/manage.py runserver 0.0.0.0:8000`
   - Celery：`celery -A core worker -l info` / `celery -A core beat -l info`
   - Nginx（可选，本地装）或使用前端代理 `/api`

### 容器化部署（Docker Compose）

1. 安装 Docker Desktop 或 Docker Engine + Compose v2
2. 准备仓库目录与 `.env`（由 `.env.example` 复制）
3. 编排文件与 Dockerfile 就绪：
   - `docker-compose.yml` 定义 `mysql`/`redis`/`backend`/`celery`/`celery-beat`/`frontend`/`nginx`
   - `backend/Dockerfile` 与 `frontend/Dockerfile` 定义镜像构建
4. 构建并启动服务：
   - `docker compose build`
   - `docker compose up -d`
5. 在容器内执行管理操作：
   - 后端迁移：`docker compose exec backend python manage.py migrate`
   - 创建超管：`docker compose exec backend python manage.py createsuperuser`
   - Celery/beat 已由 Compose 单独服务启动
6. 开发访问：
   - 前端：`http://localhost:3000`
   - 后端：`http://localhost:8000/api/health/`
   - Nginx（若启用）：`http://localhost:80`

---

## 三、关键差异点（按主题）

- 运行时归属：
  - 本地：Node/Python/依赖装在宿主机或虚拟环境。
  - 容器：Node/Python/依赖装在镜像/容器中，宿主机只要有 Docker。

- 命令入口：
  - 本地：`django-admin`、`python manage.py`、`npm run dev` 直接在宿主机执行。
  - 容器：通过 `docker compose exec backend ...`/`docker compose exec frontend ...` 在容器内执行。

- 数据服务：
  - 本地：MySQL、Redis 需要安装为本地服务并维护端口/权限。
  - 容器：使用官方镜像与卷持久化，由 Compose 管理健康检查与依赖顺序。

- 端口与网络：
  - 本地：服务默认绑定本机端口，跨服务需要本地网络连通。
  - 容器：容器间通过服务名通信（如 `mysql:3306`），对外通过端口映射。

- 配置与环境：
  - 本地：`.env.local` 或系统环境变量，注意与本地服务端口一致。
  - 容器：统一 `.env` 被 Compose 与后端读取，减少环境漂移。

- 开发体验：
  - 本地：IDE 直接读取本机依赖，补全最佳；环境一致性依赖手工维护。
  - 容器：IDE 可接入 Dev Containers 或容器解释器；环境与线上更一致。

---

## 四、常用命令对照

| 目标 | 本地部署 | 容器化部署 |
| --- | --- | --- |
| 启动所有服务 | 手工逐个启动（MySQL/Redis/后端/前端/Nginx） | `docker compose up -d` |
| 进入后端 Shell | `source .venv/bin/activate` 后 `bash` | `docker compose exec backend sh` |
| Django 迁移 | `python manage.py migrate` | `docker compose exec backend python manage.py migrate` |
| 创建超管 | `python manage.py createsuperuser` | `docker compose exec backend python manage.py createsuperuser` |
| 前端开发 | `npm run dev` | `docker compose logs -f frontend`（服务已由容器跑） |
| 查看日志 | 各进程分别查看 | `docker compose logs <service> -f` |
| 清理 | 卸载服务与删除临时数据 | `docker compose down -v` |

---

## 五、为什么容器化时“安装顺序”会改变？

在本地部署里，你必须先具备运行 `django-admin`/`npm` 的本地环境，才能生成项目与安装依赖；而在容器化里，运行时与依赖已被“搬进”镜像/容器。你只需要：

1. 先准备编排（Compose、Dockerfile 与 `.env`）。
2. 构建镜像并启动容器，让“环境”先存在于容器中。
3. 在容器内执行项目初始化、迁移、数据导入等命令。

这使得“安装顺序”从“先装语言环境 → 再建项目”变为“先起容器 → 再在容器内操作项目”。

---

## 六、建议路径

- 以容器化为主：统一环境，减少“在我电脑上能跑”的问题。
- 需要更强 IDE 体验时，可选“本机虚拟环境”开发方式（见《03_为什么没有Django命令或环境.md》中的方案B），但仍然使用容器承载 MySQL/Redis/Nginx。

---

## 七、相关文档

- 《01_构建系统.md》：从零到一构建与启动
- 《02_Docker与文件关系.md》：Compose/镜像/容器与配置文件的对应关系
- 《03_为什么没有Django命令或环境.md》：两种开发方式说明
- 《04_容器内路径与文件放置.md》：各服务在容器内的落位与验证
- 《05_为什么宿主机能看到镜像.md》：镜像/容器/进程区别


